package GetVersion;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;

import org.apache.poi.hssf.usermodel.HSSFCell;
import org.apache.poi.hssf.usermodel.HSSFCellStyle;
import org.apache.poi.hssf.usermodel.HSSFRow;
import org.apache.poi.hssf.usermodel.HSSFSheet;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.apache.poi.openxml4j.exceptions.InvalidFormatException;
import org.apache.poi.ss.usermodel.Row;

public class VulnerabilityInfo {

    ExcelUtil excelUtil = new ExcelUtil();

    public static class VulnerInfo {
        public String cve = ""; // cve号
        public String softeware = ""; // 软件名
        public String softwareVersion = ""; // 含漏洞软件版本
        public String fileName = ""; // 漏洞文件名
        public String functionName = ""; // 漏洞函数名
        public ArrayList<String> containVersions = new ArrayList<String>(); // 检查后包含漏洞的版本
        public ArrayList<String> errorVersions = new ArrayList<String>(); // 版本漏洞已经修改
        public ArrayList<String> existVersions = new ArrayList<String>(); // 文件存在的版本
        public ArrayList<String> reuseVersions = new ArrayList<String>(); // 漏洞复用代码示例
        public String report = "";// 提示说明
    }

    /**
     * 从excel中读取
     * 
     * @param filePath
     *            excel路径
     * @return 预置数据信息数组，不正确时返回{@code null}
     * @throws InvalidFormatException
     */
    ArrayList<VulnerInfo> readInfoFromExcel(String filePath) throws InvalidFormatException {
        ArrayList<VulnerInfo> vulnerInfos = new ArrayList<VulnerInfo>();
        if (filePath == null) {
            return vulnerInfos;
        }
        ArrayList<Row> rows = excelUtil.readExcelHssfRows(filePath, 0);
        if (rows.size() == 0) {
            return vulnerInfos;
        }
        rows.remove(0);
        for (Row row : rows) {
            String fileName = excelUtil.getCellStringValue(row, 4);
            if (fileName == null) {
                continue;
            }
            fileName = fileName.replaceAll("[ |　]", " ").replaceAll("\\u00A0", "").trim();
            System.out.println(fileName);
            String[] fileList = fileName.split("[;；]");

            String functionName = excelUtil.getCellStringValue(row, 5);
            String[] functionList = null;
            if (functionName != null) {
                functionList = functionName.split("[;；]");
                if (functionList.length != fileList.length) {
                    VulnerInfo vulnerInfo = new VulnerInfo();
                    vulnerInfo.cve = excelUtil.getCellStringValue(row, 0).replaceAll("[ |　]", " ")
                            .replaceAll("\\u00A0", "").trim();
                    vulnerInfo.report = "漏洞文件名和漏洞函数不匹配，请注意查看";
                    vulnerInfos.add(vulnerInfo);
                    continue;
                }
            }

            System.out.println(Arrays.toString(fileList));
            for (int i = 0; i < fileList.length; i++) {
                VulnerInfo vulnerInfo = new VulnerInfo();
                vulnerInfo.cve = excelUtil.getCellStringValue(row, 0).replaceAll("[ |　]", " ")
                        .replaceAll("\\u00A0", "").trim();
                // 软件名
                vulnerInfo.softeware = excelUtil.getCellStringValue(row, 2)
                        .replaceAll("[ |　]", " ").replaceAll("\\u00A0", "").trim();
                if (vulnerInfo.softeware.equals("Libav")) {
                    vulnerInfo.softeware = "libav";
                }
                vulnerInfo.softwareVersion = excelUtil.getCellStringValue(row, 3)
                        .replaceAll("[ |　]", " ").replaceAll("\\u00A0", "").trim();
                // 多文件处理
                vulnerInfo.fileName = fileList[i];
                if (vulnerInfo.fileName != null) {
                    vulnerInfo.fileName = vulnerInfo.fileName.replaceAll("[ |　]", " ")
                            .replaceAll("\\u00A0", "").trim();
                }
                // 多函数处理
                vulnerInfo.functionName = (functionName == null ? null : functionList[i]);
                if (vulnerInfo.functionName != null) {
                    vulnerInfo.functionName = vulnerInfo.functionName.replaceAll("[ |　]", " ")
                            .replaceAll("\\u00A0", "").trim();
                }
                vulnerInfos.add(vulnerInfo);
            }
        }
        return vulnerInfos;
    }

    /**
     * 初始化一个结果展示的Excel,并创建一个单元格样式,初始化基本值
     * 
     * @param workbook
     *            初始化的Excel
     * @return 返回创建的单元格样式{@link HSSFCellStyle}
     */
    private HSSFCellStyle initWorkbook(HSSFWorkbook workbook) {
        HSSFCellStyle cellStyle = workbook.createCellStyle();
        HSSFSheet sheet = workbook.createSheet();
        // 初始化纵向对齐方式为居中
        cellStyle.setVerticalAlignment(HSSFCellStyle.VERTICAL_CENTER);
        // 初始化单元格大小为包含文本
        cellStyle.setWrapText(true);
        // 初始化工作表的列宽
        sheet.setColumnWidth(0, 15 * 256);
        sheet.setColumnWidth(1, 15 * 256);
        sheet.setColumnWidth(2, 15 * 256);
        sheet.setColumnWidth(3, 25 * 256);
        sheet.setColumnWidth(4, 25 * 256);
        sheet.setColumnWidth(5, 40 * 256);
        sheet.setColumnWidth(6, 40 * 256);
        sheet.setColumnWidth(7, 30 * 256);
        sheet.setColumnWidth(8, 30 * 256);
        return cellStyle;
    }

    /***
     * 
     * @param vulnerInfos
     * @param excelPath
     *            结果表格路径地址
     */
    public void writeResultToExcel(ArrayList<VulnerInfo> vulnerInfos, String excelPath) {
        HSSFWorkbook workbook = new HSSFWorkbook();
        HSSFCellStyle cellStyle = initWorkbook(workbook);
        HSSFSheet sheet = workbook.getSheetAt(0);
        for (int rowIndex = 0; rowIndex < vulnerInfos.size() + 1; rowIndex++) {
            VulnerInfo vulnerInfo = rowIndex == 0 ? null : vulnerInfos.get(rowIndex - 1);
            HSSFRow row = sheet.createRow(rowIndex);
            HSSFCell cell = null;
            for (int i = 0; i < 9; i++) {
                cell = row.createCell(i);
                if (rowIndex == 0) {
                    cellStyle.setAlignment(HSSFCellStyle.ALIGN_CENTER);
                } else {
                    cellStyle.setAlignment(HSSFCellStyle.ALIGN_LEFT);
                }
                cell.setCellStyle(cellStyle);
                switch (i) {
                case 0:
                    cell.setCellValue(rowIndex == 0 ? "CVE ID" : vulnerInfo.cve);
                    break;
                case 1:
                    cell.setCellValue(rowIndex == 0 ? "Software" : vulnerInfo.softeware);
                    break;
                case 2:
                    cell.setCellValue(rowIndex == 0 ? "Software version"
                            : vulnerInfo.softwareVersion);
                    break;
                case 3:
                    cell.setCellValue(rowIndex == 0 ? "漏洞文件名" : vulnerInfo.fileName);
                    break;
                case 4:
                    cell.setCellValue(rowIndex == 0 ? "漏洞函数名" : vulnerInfo.functionName);
                    break;
                case 5:
                    cell.setCellValue(rowIndex == 0 ? "含漏洞软件版本" : (vulnerInfo.containVersions
                            .toString()));
                    break;
                case 6:
                    cell.setCellValue(rowIndex == 0 ? "漏洞已经修复过版本" : (vulnerInfo.errorVersions
                            .toString()));
                    break;
                case 7:
                    cell.setCellValue(rowIndex == 0 ? "补充说明" : vulnerInfo.report);
                    break;
                case 8:
                    cell.setCellValue(rowIndex == 0 ? "复用代码示例列表" : (vulnerInfo.reuseVersions
                            .toString()));
                    break;
                default:
                    break;
                }
            }
        }
        try {
            String path = excelPath.substring(0, excelPath.lastIndexOf("\\") + 1);
            String name = excelPath.substring(excelPath.lastIndexOf("\\") + 1);
            if (name.contains(".xlsx")) {
                name = name.replace(".xlsx", "result.xls");
            } else {
                name = name.replace(".xls", "result.xls");
            }
            new File(path).mkdirs();
            workbook.write(new FileOutputStream(path + name));
            workbook.close();
            System.out.println(path + name);
        } catch (IOException e) {
            System.out.println(e.toString());
        }
    }

    // public static void main(String[] args) throws InvalidFormatException {
    // // TODO Auto-generated method stub
    // String excelPath =
    // "C:\\Users\\wt\\Desktop\\tyy\\实验室work-tyy\\getContainVersion\\testTemp.xls";
    // VulnerabilityInfo vulnerabilityInfo = new VulnerabilityInfo();
    // ArrayList<VulnerInfo> vulnerInfos =
    // vulnerabilityInfo.readInfoFromExcel(excelPath);
    //
    // for (VulnerInfo vulnerInfo : vulnerInfos) {
    // System.out.println(vulnerInfo.softeware);
    // System.out.println(vulnerInfo.cve + "\t" + vulnerInfo.softeware + "\t"
    // + vulnerInfo.softwareVersion + "\t" + vulnerInfo.fileName + "\t"
    // + vulnerInfo.functionName);
    // vulnerInfo.containVersions.add("2.5.6");
    // vulnerInfo.containVersions.add("2.4.6");
    // vulnerInfo.containVersions.add("2.3.6");
    // }
    // System.out.println("总数：" + vulnerInfos.size());
    // vulnerabilityInfo.writeResultToExcel(vulnerInfos, excelPath);
    // }
}
