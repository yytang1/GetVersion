package GetVersion;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;

import org.apache.poi.hssf.usermodel.HSSFCell;
import org.apache.poi.hssf.usermodel.HSSFCellStyle;
import org.apache.poi.hssf.usermodel.HSSFRow;
import org.apache.poi.hssf.usermodel.HSSFSheet;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.apache.poi.openxml4j.exceptions.InvalidFormatException;
import org.apache.poi.ss.usermodel.Row;

public class VulnerabilityInfo {

    ExcelUtil excelUtil = new ExcelUtil();

    public class VulnerInfo {
        public String cve = ""; // cve号
        public String softeware = ""; // 软件名
        public String softwareVersion = ""; // 含漏洞软件版本
        public String fileName = ""; // 漏洞文件名
        public String functionName = ""; // 漏洞函数名
        public ArrayList<String> containVersions = new ArrayList<String>(); // 检查后包含漏洞的版本
        public ArrayList<String> errorVersions = new ArrayList<String>(); // 版本漏洞已经修改
    }

    /**
     * 从excel中读取
     * 
     * @param filePath
     *            excel路径
     * @return 预置数据信息数组，不正确时返回{@code null}
     * @throws InvalidFormatException
     */
    ArrayList<VulnerInfo> readInfoFromExcel(String filePath) throws InvalidFormatException {
        ArrayList<VulnerInfo> vulnerInfos = new ArrayList<VulnerInfo>();
        if (filePath == null) {
            return vulnerInfos;
        }
        ArrayList<Row> rows = excelUtil.readExcelHssfRows(filePath, 0);
        if (rows.size() == 0) {
            return vulnerInfos;
        }
        rows.remove(0);
        for (Row row : rows) {
            String fileName = excelUtil.getCellStringValue(row, 4);
            if (fileName == null) {
                continue;
            }
            String funcitonName = excelUtil.getCellStringValue(row, 5);
            System.out.println(fileName);
            String[] fileList = fileName.split("[;；]");
            System.out.println(Arrays.toString(fileList));
            String[] functionList = funcitonName.split("[;；]");
            int length = (fileList.length > functionList.length ? functionList.length
                    : fileList.length);
            for (int i = 0; i < length; i++) {
                VulnerInfo vulnerInfo = new VulnerInfo();
                vulnerInfo.cve = excelUtil.getCellStringValue(row, 0);
                // 软件名
                vulnerInfo.softeware = excelUtil.getCellStringValue(row, 2);
                vulnerInfo.softwareVersion = excelUtil.getCellStringValue(row, 3);
                // 多文件处理
                vulnerInfo.fileName = fileList[i];
                // 多函数处理
                vulnerInfo.functionName = functionList[i];
                vulnerInfos.add(vulnerInfo);
            }
        }
        return vulnerInfos;
    }

    /**
     * 初始化一个结果展示的Excel,并创建一个单元格样式,初始化基本值
     * 
     * @param workbook
     *            初始化的Excel
     * @return 返回创建的单元格样式{@link HSSFCellStyle}
     */
    private HSSFCellStyle initWorkbook(HSSFWorkbook workbook) {
        HSSFCellStyle cellStyle = workbook.createCellStyle();
        HSSFSheet sheet = workbook.createSheet();
        // 初始化纵向对齐方式为居中
        cellStyle.setVerticalAlignment(HSSFCellStyle.VERTICAL_CENTER);
        // 初始化单元格大小为包含文本
        cellStyle.setWrapText(true);
        // 初始化工作表的列宽
        sheet.setColumnWidth(0, 15 * 256);
        sheet.setColumnWidth(1, 15 * 256);
        sheet.setColumnWidth(2, 15 * 256);
        sheet.setColumnWidth(3, 25 * 256);
        sheet.setColumnWidth(4, 25 * 256);
        sheet.setColumnWidth(5, 40 * 256);
        sheet.setColumnWidth(6, 40 * 256);
        return cellStyle;
    }

    /***
     * 
     * @param vulnerInfos
     * @param excelPath
     *            结果表格路径地址
     */
    public void writeResultToExcel(ArrayList<VulnerInfo> vulnerInfos, String excelPath) {
        HSSFWorkbook workbook = new HSSFWorkbook();
        HSSFCellStyle cellStyle = initWorkbook(workbook);
        HSSFSheet sheet = workbook.getSheetAt(0);
        for (int rowIndex = 0; rowIndex < vulnerInfos.size() + 1; rowIndex++) {
            VulnerInfo vulnerInfo = rowIndex == 0 ? null : vulnerInfos.get(rowIndex - 1);
            HSSFRow row = sheet.createRow(rowIndex);
            HSSFCell cell = null;
            for (int i = 0; i < 7; i++) {
                cell = row.createCell(i);
                if (rowIndex == 0) {
                    cellStyle.setAlignment(HSSFCellStyle.ALIGN_CENTER);
                } else {
                    cellStyle.setAlignment(HSSFCellStyle.ALIGN_LEFT);
                }
                cell.setCellStyle(cellStyle);
                switch (i) {
                case 0:
                    cell.setCellValue(rowIndex == 0 ? "CVE ID" : vulnerInfo.cve);
                    break;
                case 1:
                    cell.setCellValue(rowIndex == 0 ? "Software" : vulnerInfo.softeware);
                    break;
                case 2:
                    cell.setCellValue(rowIndex == 0 ? "Software version"
                            : vulnerInfo.softwareVersion);
                    break;
                case 3:
                    cell.setCellValue(rowIndex == 0 ? "漏洞文件名" : vulnerInfo.fileName);
                    break;
                case 4:
                    cell.setCellValue(rowIndex == 0 ? "漏洞函数名" : vulnerInfo.functionName);
                    break;
                case 5:
                    cell.setCellValue(rowIndex == 0 ? "含漏洞软件版本" : (vulnerInfo.containVersions
                            .toString()));
                    break;
                case 6:
                    cell.setCellValue(rowIndex == 0 ? "漏洞已经修复过版本" : (vulnerInfo.errorVersions
                            .toString()));
                default:
                    break;
                }
            }
        }
        try {
            String path = excelPath.substring(0, excelPath.lastIndexOf("\\") + 1);
            String name = excelPath.substring(excelPath.lastIndexOf("\\") + 1);
            if (name.contains(".xlsx")) {
                name = name.replace(".xlsx", "result.xls");
            } else {
                name = name.replace(".xls", "result.xls");
            }
            new File(path).mkdir();
            workbook.write(new FileOutputStream(path + name));
            workbook.close();
            System.out.println(path + name);
        } catch (IOException e) {
            System.out.println(e.toString());
        }
    }

    public static void main(String[] args) throws InvalidFormatException {
        // TODO Auto-generated method stub
        String excelPath = "C:\\Users\\yytang\\Desktop\\all\\工作簿1.xlsx";
        VulnerabilityInfo vulnerabilityInfo = new VulnerabilityInfo();
        ArrayList<VulnerInfo> vulnerInfos = vulnerabilityInfo.readInfoFromExcel(excelPath);

        for (VulnerInfo vulnerInfo : vulnerInfos) {
            System.out.println(vulnerInfo.cve + "\t" + vulnerInfo.softeware + "\t"
                    + vulnerInfo.softwareVersion + "\t" + vulnerInfo.fileName + "\t"
                    + vulnerInfo.functionName);
            vulnerInfo.containVersions.add("2.5.6");
            vulnerInfo.containVersions.add("2.4.6");
            vulnerInfo.containVersions.add("2.3.6");
        }
        System.out.println("总数：" + vulnerInfos.size());
        vulnerabilityInfo.writeResultToExcel(vulnerInfos, excelPath);
    }
}
